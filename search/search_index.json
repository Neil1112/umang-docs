{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Umang Wellness Guides We have created list of guides to help you get the most out of our platform. Our guides covers all roles as of the version v2.0 which are Client and Counsellor . Check the following links to look for guides related to one of these roles and other role-unrelated guides. Business Flow Guide Semantic Versioning Tech Stack & Code Architecture/Organisation Branch Description Guide","title":"Welcome to Umang Wellness Guides"},{"location":"#welcome-to-umang-wellness-guides","text":"We have created list of guides to help you get the most out of our platform. Our guides covers all roles as of the version v2.0 which are Client and Counsellor . Check the following links to look for guides related to one of these roles and other role-unrelated guides. Business Flow Guide Semantic Versioning Tech Stack & Code Architecture/Organisation Branch Description Guide","title":"Welcome to Umang Wellness Guides"},{"location":"architecture/","text":"Tech Stack & Code Architecture/Organisation This document gives the description of the technologies involved, and the project architecture. Technologies The Project is structured in a Monolith structure. Thus the production (i.e - the master branch) has: Single server Single remote database The Stack The tech-stack chosen for the project is the MERN stack. MERN stands for a group of four technologies used in synergy. M stands for MongoDB - A NoSQL Database E stands for ExpressJS - A minimalist web framework for NodeJS R stands for ReactJS - A frontend library N stands for NodeJS - A Javascript Runtime Environment Database details MongoDB is chosen as the database for the project. It is a NoSQL database. Its cloud solutioln named MongoDB Atlas is integrated in the project. The details for the current configuration is as follows: Database Type - Cloud Service Name - MongoDB Atlas Cluster Type - Shared Cloud Provider - Google Region - Mumbai (asia-south-1) Cluster Tier - M0 Sandbox Cluster Tier Pricing - FREE Connection String - mongodb+srv://admin: ENTER_PASSWORD %21@cluster0.x2jgv.gcp.mongodb.net/admin Version Control and Branches Git is used as the Version Control System for the Project. It is configured as a private repository on Github. Github Repository - https://github.com/cjaykumar/umangwellness Branches There are a total of 6 branches configured in the Project. They are as follows - master dev dev1.1 rajeev-branch rajeev\u2019s-branch rc 1.1 Major branches - master, dev and rc 1.1 master Branch Responsible for LIVE Production code Hosted on - Azure Web App Services Currently hosted at - https://umangprod.azurewebsites.net dev Branch Responsible for Development code Hosted on - Azure Web App Services Currently hosted at - https://umang-dev.azurewebsites.net rc1.1 Branch Responsible for a standby stable candidate to push immediately to master, if some bug is encountered on the production site Code Architecture and Organisation The code is divided into 2 major modules - client and server. [![fig-1]][fig-1] [fig-1]: ./../img/general/contact-us-1.png In the above figure, the directory client represents the frontend part. The rest of the directories and files make up the server. The Approach is SPA - Single Page Application implemented using NodeJS as server side and ReactJS for the frontend. The API in the server uses the REST technology with the standard HTTP methods. Server Side server.js server.js is the single entry point governing different environments [production, development, test]. server.js is also responsible for mapping routes to their respective controllers. package.json The package.json is responsible for maintaining 2 important things - scripts and dependencies Scripts are pieces of code which are run in specific scenarios to allow a custom configuration to the code. For example - Scripts can be used to start the server or configure the system into test mode. Dependencies: Dependencies are mainly pieces of softwares called packages which are developed by other programmers and published on npm. Dependencies are of 2 types, namely - dependencies and devDependencies devDependencies are specific to particular developer, and should play no role in project development Routes and Controllers The routes directory is responsible for maintaining and organising various api routes logically. It is also responsible for routing a given url to its respective controller. Walkthrough of an example URL - api/admin/sendCustomEmail The above url is responsible for custom emails written by admin to multiple clients and counsellors existing in the system. The url is parsed by the server.js middleware and will pass it to the appropriate router. The url is then passed to the admin router - adminRouter. The adminRouter consists of all the mappings of urls related to admin and their respective controllers. The url is also differentiated by its HTTP method type - GET, POST, etc. Finally, according to the url and the HTTP method defined, the router passes the query to its respective controller. The above figure shows the sendCustomEmailController, which is responsible for sending custom emails to clients and counsellors. List of routers The list of routers currently existing in the system is shown in the figure below Config Directory The config directory contains files for specific purposes like background services, database urls, environment variables, keys for various packages, etc. github/workflows This directory is responsible for holding github actions workflow file. The file dev_umang-dev.yml shown in the below example is responsible for defining all the processes and their precedence of the dev branch whenever a new code is pushed. Models Models in the code resemble the structure of database collections in MongoDB. They are responsible for defining the data-fields, the type related to the data-fields, defining relationships between two models, defining required and default fields, etc. The list of model currently defined is as follows - Models are used throughout the code for maintaining consistency in the data-fields for a particular document. Client Side The client directory contains all the code needed to create and manage the frontend part of the system. The structure of the client directory is as follows - The directory that is of the most interest to us, is the src directory. build, node_modules and public directories are of not that much interest to us. package.json is another file that is important to us. package.json The package.json is responsible for maintaining the dependencies and scripts for the client side. The current package dependencies for the client side is shown in the figure below - The scripts for the client side are shown in the following figure - The two important scripts here are start and sitemap. start is used to run the client side and sitemap is used to generate a sitemap automatically. src directory The src directory contains all the important code. The directory named assets, contains media files for the pages. index.js This file, like the server.js, is the single entry point for the client side. It is responsible for rendering the root element in the document. We abstract its logic in another file named App.js. The index.js wraps the App component by AuthProvider and ThemeProvider. Thus allowing all the files and components in the app to use the services offered by AuthProvider and ThemeProvider. App.js Like the routing middleware in the server.js which is responsible for matching a given URL to its given controller, the App.js maps a given URL to its respective UI component. It also takes into account what URL requires what kind of role access. If the role access requirement is not met, it does not allow the URL to be accessed and falls back to the home page. There are 3 types of routes defined - Route, UnPrivateRoute and PrivateRoute Route - It is accessible whether the user is signed in or not. Thus it makes sense to use it for all static pages. PrivateRoute - PrivateRoute takes an array of roles as its parameter to determine which role(s) is/are allowed access to a specific URL. UnPrivateRoute - While PrivateRoute are only visible after signing in; the UnPrivateRoute cannot be accessed after signing in. They are used for URLs similar to Sign Up, Sign In, Forget Password, etc - which are used only at the time of signing in. Once the user is signed in, these URLs makes no sense, and hence must be hidden from the user HOCs The HOC directory stands for - Higher Order Components. These are custom components that are made upon existing components to achieve some specific results. The HOC includes - NetworkDetector, PrivateRoute and UnPrivateRoute The NetworkDetector is responsible for determining active Internet connection. If the Internet somehow goes inactive, the NetworkDetector will let the UI components know about it. The UI component can then handle how it wants to interpret the information and display it to the user. PrivateRoute as mentioned earlier, is a mean to provide a role based access to various components UnPrivateRoute is a means to disable certain URLs after a user has signed in. Services Services are meant to abstract and organise the logic for exchanging requests with the server. They help us in - Reducing the amount of code caused by repeating the same code by mentioning it at the same place. Allowing any component to access the services. Hence allowing the components to concentrate more upon their custom logic. Easily Tested and limiting the error to them. Hence components can rely on them without worrying about testing the logic and preventing the errors. Allows us to organise all the services related to a particular domain under one hood. For example, we can group all the services offered by Admin under one hood, as can be seen in the below figure. contexts The context directory is responsible for maintaining some information and making it accessible across all components. There are 3 contexts currently deployed - AuthContext, SelectedCounsellorContext and ThemeContext. AuthContext AuthContext lets a component know whether a user has signed in or not. It also lets the component know what role access the user has. It also lets the component know about the selected timezone by the user. It lets the components know that the site is under maintenance or is updated to a newer version. SelectedCounsellorContext The SelectedCounsellorContext, lets the components of the client know whether the client has selected a counsellor or not. If the client has selected the counsellor, then it also let\u2019s the components know the details about the counsellor. It is developed to avoid recursive calls to the API for fetching counsellor information everytime a client component requests for it. ThemeContext The ThemeContext serves as a single destination to mention the theme related fields. It also solves the problem of updating the theme everywhere, if it changes. It allows us to mention the theme fields at one place, and reuse them in all the components. Currently the ThemeContext manages colors, fontFamily, fontSize and a custom theme for buttons, paragraphs, texts, forms, etc.","title":"Tech Stack & Code Architecture/Organisation"},{"location":"architecture/#tech-stack-code-architectureorganisation","text":"This document gives the description of the technologies involved, and the project architecture.","title":"Tech Stack &amp; Code Architecture/Organisation"},{"location":"architecture/#technologies","text":"The Project is structured in a Monolith structure. Thus the production (i.e - the master branch) has: Single server Single remote database","title":"Technologies"},{"location":"architecture/#the-stack","text":"The tech-stack chosen for the project is the MERN stack. MERN stands for a group of four technologies used in synergy. M stands for MongoDB - A NoSQL Database E stands for ExpressJS - A minimalist web framework for NodeJS R stands for ReactJS - A frontend library N stands for NodeJS - A Javascript Runtime Environment","title":"The Stack"},{"location":"architecture/#database-details","text":"MongoDB is chosen as the database for the project. It is a NoSQL database. Its cloud solutioln named MongoDB Atlas is integrated in the project. The details for the current configuration is as follows: Database Type - Cloud Service Name - MongoDB Atlas Cluster Type - Shared Cloud Provider - Google Region - Mumbai (asia-south-1) Cluster Tier - M0 Sandbox Cluster Tier Pricing - FREE Connection String - mongodb+srv://admin: ENTER_PASSWORD %21@cluster0.x2jgv.gcp.mongodb.net/admin","title":"Database details"},{"location":"architecture/#version-control-and-branches","text":"Git is used as the Version Control System for the Project. It is configured as a private repository on Github. Github Repository - https://github.com/cjaykumar/umangwellness","title":"Version Control and Branches"},{"location":"architecture/#branches","text":"There are a total of 6 branches configured in the Project. They are as follows - master dev dev1.1 rajeev-branch rajeev\u2019s-branch rc 1.1 Major branches - master, dev and rc 1.1","title":"Branches"},{"location":"architecture/#master-branch","text":"Responsible for LIVE Production code Hosted on - Azure Web App Services Currently hosted at - https://umangprod.azurewebsites.net","title":"master Branch"},{"location":"architecture/#dev-branch","text":"Responsible for Development code Hosted on - Azure Web App Services Currently hosted at - https://umang-dev.azurewebsites.net","title":"dev Branch"},{"location":"architecture/#rc11-branch","text":"Responsible for a standby stable candidate to push immediately to master, if some bug is encountered on the production site","title":"rc1.1 Branch"},{"location":"architecture/#code-architecture-and-organisation","text":"The code is divided into 2 major modules - client and server. [![fig-1]][fig-1] [fig-1]: ./../img/general/contact-us-1.png In the above figure, the directory client represents the frontend part. The rest of the directories and files make up the server. The Approach is SPA - Single Page Application implemented using NodeJS as server side and ReactJS for the frontend. The API in the server uses the REST technology with the standard HTTP methods.","title":"Code Architecture and Organisation"},{"location":"architecture/#server-side","text":"","title":"Server Side"},{"location":"architecture/#serverjs","text":"server.js is the single entry point governing different environments [production, development, test]. server.js is also responsible for mapping routes to their respective controllers.","title":"server.js"},{"location":"architecture/#packagejson","text":"The package.json is responsible for maintaining 2 important things - scripts and dependencies Scripts are pieces of code which are run in specific scenarios to allow a custom configuration to the code. For example - Scripts can be used to start the server or configure the system into test mode. Dependencies: Dependencies are mainly pieces of softwares called packages which are developed by other programmers and published on npm. Dependencies are of 2 types, namely - dependencies and devDependencies devDependencies are specific to particular developer, and should play no role in project development","title":"package.json"},{"location":"architecture/#routes-and-controllers","text":"The routes directory is responsible for maintaining and organising various api routes logically. It is also responsible for routing a given url to its respective controller.","title":"Routes and Controllers"},{"location":"architecture/#walkthrough-of-an-example-url-apiadminsendcustomemail","text":"The above url is responsible for custom emails written by admin to multiple clients and counsellors existing in the system. The url is parsed by the server.js middleware and will pass it to the appropriate router. The url is then passed to the admin router - adminRouter. The adminRouter consists of all the mappings of urls related to admin and their respective controllers. The url is also differentiated by its HTTP method type - GET, POST, etc. Finally, according to the url and the HTTP method defined, the router passes the query to its respective controller. The above figure shows the sendCustomEmailController, which is responsible for sending custom emails to clients and counsellors.","title":"Walkthrough of an example URL - api/admin/sendCustomEmail"},{"location":"architecture/#list-of-routers","text":"The list of routers currently existing in the system is shown in the figure below","title":"List of routers"},{"location":"architecture/#config-directory","text":"The config directory contains files for specific purposes like background services, database urls, environment variables, keys for various packages, etc.","title":"Config Directory"},{"location":"architecture/#githubworkflows","text":"This directory is responsible for holding github actions workflow file. The file dev_umang-dev.yml shown in the below example is responsible for defining all the processes and their precedence of the dev branch whenever a new code is pushed.","title":"github/workflows"},{"location":"architecture/#models","text":"Models in the code resemble the structure of database collections in MongoDB. They are responsible for defining the data-fields, the type related to the data-fields, defining relationships between two models, defining required and default fields, etc. The list of model currently defined is as follows - Models are used throughout the code for maintaining consistency in the data-fields for a particular document.","title":"Models"},{"location":"architecture/#client-side","text":"The client directory contains all the code needed to create and manage the frontend part of the system. The structure of the client directory is as follows - The directory that is of the most interest to us, is the src directory. build, node_modules and public directories are of not that much interest to us. package.json is another file that is important to us.","title":"Client Side"},{"location":"architecture/#packagejson_1","text":"The package.json is responsible for maintaining the dependencies and scripts for the client side. The current package dependencies for the client side is shown in the figure below - The scripts for the client side are shown in the following figure - The two important scripts here are start and sitemap. start is used to run the client side and sitemap is used to generate a sitemap automatically.","title":"package.json"},{"location":"architecture/#src-directory","text":"The src directory contains all the important code. The directory named assets, contains media files for the pages.","title":"src directory"},{"location":"architecture/#indexjs","text":"This file, like the server.js, is the single entry point for the client side. It is responsible for rendering the root element in the document. We abstract its logic in another file named App.js. The index.js wraps the App component by AuthProvider and ThemeProvider. Thus allowing all the files and components in the app to use the services offered by AuthProvider and ThemeProvider.","title":"index.js"},{"location":"architecture/#appjs","text":"Like the routing middleware in the server.js which is responsible for matching a given URL to its given controller, the App.js maps a given URL to its respective UI component. It also takes into account what URL requires what kind of role access. If the role access requirement is not met, it does not allow the URL to be accessed and falls back to the home page. There are 3 types of routes defined - Route, UnPrivateRoute and PrivateRoute Route - It is accessible whether the user is signed in or not. Thus it makes sense to use it for all static pages. PrivateRoute - PrivateRoute takes an array of roles as its parameter to determine which role(s) is/are allowed access to a specific URL. UnPrivateRoute - While PrivateRoute are only visible after signing in; the UnPrivateRoute cannot be accessed after signing in. They are used for URLs similar to Sign Up, Sign In, Forget Password, etc - which are used only at the time of signing in. Once the user is signed in, these URLs makes no sense, and hence must be hidden from the user","title":"App.js"},{"location":"architecture/#hocs","text":"The HOC directory stands for - Higher Order Components. These are custom components that are made upon existing components to achieve some specific results. The HOC includes - NetworkDetector, PrivateRoute and UnPrivateRoute The NetworkDetector is responsible for determining active Internet connection. If the Internet somehow goes inactive, the NetworkDetector will let the UI components know about it. The UI component can then handle how it wants to interpret the information and display it to the user. PrivateRoute as mentioned earlier, is a mean to provide a role based access to various components UnPrivateRoute is a means to disable certain URLs after a user has signed in.","title":"HOCs"},{"location":"architecture/#services","text":"Services are meant to abstract and organise the logic for exchanging requests with the server. They help us in - Reducing the amount of code caused by repeating the same code by mentioning it at the same place. Allowing any component to access the services. Hence allowing the components to concentrate more upon their custom logic. Easily Tested and limiting the error to them. Hence components can rely on them without worrying about testing the logic and preventing the errors. Allows us to organise all the services related to a particular domain under one hood. For example, we can group all the services offered by Admin under one hood, as can be seen in the below figure.","title":"Services"},{"location":"architecture/#contexts","text":"The context directory is responsible for maintaining some information and making it accessible across all components. There are 3 contexts currently deployed - AuthContext, SelectedCounsellorContext and ThemeContext.","title":"contexts"},{"location":"architecture/#authcontext","text":"AuthContext lets a component know whether a user has signed in or not. It also lets the component know what role access the user has. It also lets the component know about the selected timezone by the user. It lets the components know that the site is under maintenance or is updated to a newer version.","title":"AuthContext"},{"location":"architecture/#selectedcounsellorcontext","text":"The SelectedCounsellorContext, lets the components of the client know whether the client has selected a counsellor or not. If the client has selected the counsellor, then it also let\u2019s the components know the details about the counsellor. It is developed to avoid recursive calls to the API for fetching counsellor information everytime a client component requests for it.","title":"SelectedCounsellorContext"},{"location":"architecture/#themecontext","text":"The ThemeContext serves as a single destination to mention the theme related fields. It also solves the problem of updating the theme everywhere, if it changes. It allows us to mention the theme fields at one place, and reuse them in all the components. Currently the ThemeContext manages colors, fontFamily, fontSize and a custom theme for buttons, paragraphs, texts, forms, etc.","title":"ThemeContext"},{"location":"branch-description-guide/","text":"Branch Description Guide This document lists the description of the git branches of the project. It lists the purpose of the branch, along with its environment, other configurations like database attached and the various checks one must do when commiting their work. By understanding the branches, we will understand the workflow of the development process. Important branches There are five important branches in the project. These branches are listed down in the table below: Branch name master dev e2e alpha rc Branch Workflow There are 5 major branches that participate in the development cycle. There are several resources which are shared by dev , e2e , alpha and rc branches. These are listed as follow: Resource Description JWT_SECRET_OR_KEY NSDevelopers TWILIO_SMS_ACCOUNT_SID AC6b8a7f251d357fee94f2e9b203b411fd TWILIO_SMS_AUTH_TOKEN efbbf0f42e469bcd62f5f87a821f0c60 GOOGLEAUTH_CLIENT_ID 92783308442-uts2q3bmagdfbj7br6g7igg48e9qqgk5.apps.googleusercontent.com GOOGLEAUTH_CLIENT_SECRET cRoE7ULcMyd63LfqhJve7sds GOOGLEMAIL_TYPE service_account GOOGLEMAIL_PROJECT_ID umangwellness-286808 GOOGLEMAIL_PRIVATE_KEY_ID a53e5cd430b418b9e6b280c4e6211d16187373a2 GOOGLEMAIL_CLIENT_EMAIL support-umagwellness@umangwellness-286808.iam.gserviceaccount.com GOOGLEMAIL_CLIENT_ID 101789851039019824166 GOOGLEMAIL_AUTH_URI https://accounts.google.com/o/oauth2/auth GOOGLEMAIL_TOKEN_URI https://oauth2.googleapis.com/token GOOGLEMAIL_AUTH_PROVIDER_X509_CERT_URL https://www.googleapis.com/oauth2/v1/certs GOOGLEMAIL_CLIENT_X509_CERT_URL https://www.googleapis.com/robot/v1/metadata/x509/support-umagwellness%40umangwellness-286808.iam.gserviceaccount.com CHAT_ACCOUNT_SID AC6b8a7f251d357fee94f2e9b203b411fd CHAT_AUTH_TOKEN efbbf0f42e469bcd62f5f87a821f0c60 CHAT_API_KEY SK8f823dd68f2def2cd0fbcb0633034e7a CHAT_API_SECRET X2lfYrfpFCuWbmkWRLyz7msNN0KLmcWL CHAT_SERVICE_SID IS373c6b6939ef48fcaf602fc738af62d1 Let's look at these branches one at a time. dev branch The dev branch is responsible for all the new development code in either backend or frontend. It's purpose is to track the new code being developed for the next version. Resource Description Enviornment development Database Dev - mongodb+srv://neil:developer@cluster0-xf1az.gcp.mongodb.net/umangwellness-dev-new?retryWrites=true&w=majority server port 5000 Azure web-service instance umang-dev Hosted at https://umang-dev.azurewebsites.net Version example 1.2.2 List of things that the dev branch is responsible for: Any new development in either backend or frontend. Developing new code for next version. Serving umang-dev instance at https://umang-dev.azurewebsites.net , which reflects the latest commited developments in the code. The first step for any MAJOR, MINOR or PATCH release. In case of quick fix required in the production the website is put into maintainence mode, and the fix is first applied in rc branch to quickly merge the changes in the master branch. Once the changes are pushed to master , they must be reflected then in the dev branch. Test Driven Development (TDD) is followed in the development process. Hence all the integration testing is being done in the dev branch only. alpha branch The alpha branch is responsible for all the testing on the newly developed code in the dev branch. Once the code is developed for any version in the dev branch, it is then merged into the alpha branch for testing. There are 3 types of testing - integration, e2e and manual. Integration testing is being done in the dev branch, and the e2e and manual testing are then done in the alpha branch. If the code is updated in the alpha branch, then apply the suffix in the versioning properly as shown in the table below: Resource Description Enviornment alpha Database Alpha - mongodb+srv://alpha@cluster0-xf1az.gcp.mongodb.net/umangwellness-dev-new?retryWrites=true&w=majority server port 5000 Azure web-service instance umang-test Hosted at https://umang-test.azurewebsites.net Version example 1.2.2-a.1 List of things that the dev branch is responsible for: For creating the base for e2e testing. e2e testing is done in the e2e branch, which gets all the code from the alpha branch. For doing the manual testing once the e2e tests passes. If there is any error/bug found in any of the testing phase, then they must be fixed in the dev branch, and then the fixes should be merged into the alpha branch. Hence there is a cycle between dev-alpha-testing. Once we feel confident about the code in the alpha branch, we merge it into the rc (release candidate) branch. Serving umang-test instance at https://umang-test.azurewebsites.net , which reflects the latest commited developments in the code. On this hosted-instance, the manual testing should be done. e2e branch The e2e branch is solely responsible for the End to End testing of the frontend code for the next version. It gets its code from the alpha branch. If there is any bug found, then it must be fixed in the dev branch and then merge it to the alpha branch. Resource Description Enviornment e2e-test Database created on the fly server port 5000 rc branch Once we are confident about the stability of the code after running the tests in the alpha branch, we merge the code in the rc branch to make it ready to release. The purpose of the rc branch is to keep the base ready at all time that is exactly identical to the production (i.e - master branch). The idea is, if there is any quick fix required in the production, then it is immediately addressed in the rc branch and the fix is merged in the master branch for quick release. The rc branch is almost identical to the master branch, but have few configuration changes. If the code is updated in the rc branch, then apply the suffix in the versioning properly as shown in the table below: Resource Description Enviornment release-candidate Database Prod-Clone - mongodb+srv://prod-clone@cluster0-xf1az.gcp.mongodb.net/umangwellness-dev-new?retryWrites=true&w=majority server port 80 Version example 1.2.2-rc.2 All other services and APIs are same as the master branch. Note - some of the features may be turned off in the rc branch to avoid unneccesary constraints. master branch The master branch is responsible to host the production version. No changes should directly be done in the master branch. In case of small bug fix, turn the site into maintenance mode, apply the changes in the rc branch and then deploy the changes in the master branch. The bug should then be addressed in the dev branch and tested fully and then a new version with an incremented patch must be deployed. Resource Description Enviornment production Database Prod - link not written for security reasons server port 80 Azure web-service instance umangprod Hosted at www.umangwellness.com","title":"Branch Description Guide"},{"location":"branch-description-guide/#branch-description-guide","text":"This document lists the description of the git branches of the project. It lists the purpose of the branch, along with its environment, other configurations like database attached and the various checks one must do when commiting their work. By understanding the branches, we will understand the workflow of the development process.","title":"Branch Description Guide"},{"location":"branch-description-guide/#important-branches","text":"There are five important branches in the project. These branches are listed down in the table below: Branch name master dev e2e alpha rc","title":"Important branches"},{"location":"branch-description-guide/#branch-workflow","text":"There are 5 major branches that participate in the development cycle. There are several resources which are shared by dev , e2e , alpha and rc branches. These are listed as follow: Resource Description JWT_SECRET_OR_KEY NSDevelopers TWILIO_SMS_ACCOUNT_SID AC6b8a7f251d357fee94f2e9b203b411fd TWILIO_SMS_AUTH_TOKEN efbbf0f42e469bcd62f5f87a821f0c60 GOOGLEAUTH_CLIENT_ID 92783308442-uts2q3bmagdfbj7br6g7igg48e9qqgk5.apps.googleusercontent.com GOOGLEAUTH_CLIENT_SECRET cRoE7ULcMyd63LfqhJve7sds GOOGLEMAIL_TYPE service_account GOOGLEMAIL_PROJECT_ID umangwellness-286808 GOOGLEMAIL_PRIVATE_KEY_ID a53e5cd430b418b9e6b280c4e6211d16187373a2 GOOGLEMAIL_CLIENT_EMAIL support-umagwellness@umangwellness-286808.iam.gserviceaccount.com GOOGLEMAIL_CLIENT_ID 101789851039019824166 GOOGLEMAIL_AUTH_URI https://accounts.google.com/o/oauth2/auth GOOGLEMAIL_TOKEN_URI https://oauth2.googleapis.com/token GOOGLEMAIL_AUTH_PROVIDER_X509_CERT_URL https://www.googleapis.com/oauth2/v1/certs GOOGLEMAIL_CLIENT_X509_CERT_URL https://www.googleapis.com/robot/v1/metadata/x509/support-umagwellness%40umangwellness-286808.iam.gserviceaccount.com CHAT_ACCOUNT_SID AC6b8a7f251d357fee94f2e9b203b411fd CHAT_AUTH_TOKEN efbbf0f42e469bcd62f5f87a821f0c60 CHAT_API_KEY SK8f823dd68f2def2cd0fbcb0633034e7a CHAT_API_SECRET X2lfYrfpFCuWbmkWRLyz7msNN0KLmcWL CHAT_SERVICE_SID IS373c6b6939ef48fcaf602fc738af62d1 Let's look at these branches one at a time.","title":"Branch Workflow"},{"location":"branch-description-guide/#dev-branch","text":"The dev branch is responsible for all the new development code in either backend or frontend. It's purpose is to track the new code being developed for the next version. Resource Description Enviornment development Database Dev - mongodb+srv://neil:developer@cluster0-xf1az.gcp.mongodb.net/umangwellness-dev-new?retryWrites=true&w=majority server port 5000 Azure web-service instance umang-dev Hosted at https://umang-dev.azurewebsites.net Version example 1.2.2 List of things that the dev branch is responsible for: Any new development in either backend or frontend. Developing new code for next version. Serving umang-dev instance at https://umang-dev.azurewebsites.net , which reflects the latest commited developments in the code. The first step for any MAJOR, MINOR or PATCH release. In case of quick fix required in the production the website is put into maintainence mode, and the fix is first applied in rc branch to quickly merge the changes in the master branch. Once the changes are pushed to master , they must be reflected then in the dev branch. Test Driven Development (TDD) is followed in the development process. Hence all the integration testing is being done in the dev branch only.","title":"dev branch"},{"location":"branch-description-guide/#alpha-branch","text":"The alpha branch is responsible for all the testing on the newly developed code in the dev branch. Once the code is developed for any version in the dev branch, it is then merged into the alpha branch for testing. There are 3 types of testing - integration, e2e and manual. Integration testing is being done in the dev branch, and the e2e and manual testing are then done in the alpha branch. If the code is updated in the alpha branch, then apply the suffix in the versioning properly as shown in the table below: Resource Description Enviornment alpha Database Alpha - mongodb+srv://alpha@cluster0-xf1az.gcp.mongodb.net/umangwellness-dev-new?retryWrites=true&w=majority server port 5000 Azure web-service instance umang-test Hosted at https://umang-test.azurewebsites.net Version example 1.2.2-a.1 List of things that the dev branch is responsible for: For creating the base for e2e testing. e2e testing is done in the e2e branch, which gets all the code from the alpha branch. For doing the manual testing once the e2e tests passes. If there is any error/bug found in any of the testing phase, then they must be fixed in the dev branch, and then the fixes should be merged into the alpha branch. Hence there is a cycle between dev-alpha-testing. Once we feel confident about the code in the alpha branch, we merge it into the rc (release candidate) branch. Serving umang-test instance at https://umang-test.azurewebsites.net , which reflects the latest commited developments in the code. On this hosted-instance, the manual testing should be done.","title":"alpha branch"},{"location":"branch-description-guide/#e2e-branch","text":"The e2e branch is solely responsible for the End to End testing of the frontend code for the next version. It gets its code from the alpha branch. If there is any bug found, then it must be fixed in the dev branch and then merge it to the alpha branch. Resource Description Enviornment e2e-test Database created on the fly server port 5000","title":"e2e branch"},{"location":"branch-description-guide/#rc-branch","text":"Once we are confident about the stability of the code after running the tests in the alpha branch, we merge the code in the rc branch to make it ready to release. The purpose of the rc branch is to keep the base ready at all time that is exactly identical to the production (i.e - master branch). The idea is, if there is any quick fix required in the production, then it is immediately addressed in the rc branch and the fix is merged in the master branch for quick release. The rc branch is almost identical to the master branch, but have few configuration changes. If the code is updated in the rc branch, then apply the suffix in the versioning properly as shown in the table below: Resource Description Enviornment release-candidate Database Prod-Clone - mongodb+srv://prod-clone@cluster0-xf1az.gcp.mongodb.net/umangwellness-dev-new?retryWrites=true&w=majority server port 80 Version example 1.2.2-rc.2 All other services and APIs are same as the master branch. Note - some of the features may be turned off in the rc branch to avoid unneccesary constraints.","title":"rc branch"},{"location":"branch-description-guide/#master-branch","text":"The master branch is responsible to host the production version. No changes should directly be done in the master branch. In case of small bug fix, turn the site into maintenance mode, apply the changes in the rc branch and then deploy the changes in the master branch. The bug should then be addressed in the dev branch and tested fully and then a new version with an incremented patch must be deployed. Resource Description Enviornment production Database Prod - link not written for security reasons server port 80 Azure web-service instance umangprod Hosted at www.umangwellness.com","title":"master branch"},{"location":"business-flow-guide/","text":"Business Flow Guide The Umang Wellness platform is primarily focused on providing psychological services on the web by bringing the client and counsellor together. This guide gives all the information on how the Umang Wellness platform is structured and what you should know from the business perspective. It gives detailed information about all the different modules that affect the business. Multi Role users From version v2.0, Umang Wellness platform allows Multi Role users. There are 3 roles on the platform as follow: Client Counsellor Admin A user can have either one or more roles. A user can have all the roles at once, i.e - a user can be all Client , Counsellor , and Admin at once. To learn more about them, check out the Client guides , Counsellor guides and Admin guides respectively. Client The Client is the primary user on the platform. Client is supposed to be the service consumer. Anyone can become a client by simply signing-up as Client. Once a client has signed-up he/she needs to complete his/her profile to get started. In order to complete the profile, the client also needs to verify his/her mobile number through OTP. Once the Client has completed his/her profile and verified himself/herself, he/she can then start using the service. Following are some of the things that a Client can do: View the list of Counsellors on the platform. Select the Counsellor of his/her choice. Book sessions with the selected Counsellor. Subscribe to the Counsellor to get access to 24/7 chat and bundled sessions. Counsellor The Counsellor is the service provider on the platform. Anyone can become a counsellor, until they are aligning with some mandatory requirements to become a counsellor. In order to sign-up as a Counsellor, one needs to provide the information about his/her quaification and specialities. Once that information is filled, one needs to confirm to some mandatory requirements to provide counselling on the platform. A Counsellor needs to wait for an approval by the Admin after signing-up. The Admin may contact the newly signed-up counsellor through his/her provided email to do some checks and verifications. The Counsellor needs to complete his Profile , set Available Timings and set My Pricings in order to start providing counselling services to clients. Following is the list of some things that the Counsellor can do: Set Availale Timings for session Set custom pricings to mode of services. Create Subscription plans for Clients to allow 24/7 chat and bundled sessions. From v2.0, we are introducing Counsellor Subscriptions. Everything that a counsellor can provide has a limit-cap. These subscriptions provide a means to increase that limit-caps. By default, the counsellor gets a free subscription when he signs-up. A counsellor can always upgrade/downgrade a subscription. In case of downgrade, the refund will be processed for the remanining days in the subscription. Admin The Admin is the web-app's administrator. He/She can keep track of list of all clients and counsellors. They can activate/deactivate any user. Admins are also responsible for configuring various parameters in the system. These parameters can be minimum charge for each session, advance booking days limit, payment cycle period, etc. Admin is also responisble to approve new counsellors. They are also responsible for managing the subscription plans for the counsellors. An Admin can also add new counsellors by his/her own into the system. These newly added profiles by the admin remains unverified, until a user requests to claim it. The admin can see all the payment transaction in the system. He is responsible to send the payments to counsellors. He is also responsible to send full-refunds to clients when a counsellor cancels a session. The admin is also able to view various logs. For example he is able to see the Audit logs, which keeps track of any update operation. He can also view the Error logs, which shows any error faced by a user. How do we add new counsellors? There are 2 ways in which new counsellors can be added into the system: User himself creates the profile Admin adds the profile Any user can become a counsellor by going through the sign-up process of becoming a counsellor. Once he does that, he needs to wait for an approval from the admin. Meanwhile he needs to complete his profile, verify his phone number, and set his availability timings and pricings. Once he goes through all these steps, he is listed as a verified counsellor in the public counsellor list, and is ready to provide services to clients. An admin can also add a counsellor profile. The admin may have got this information from scrape data. He may have come across this counsellor on the internet. If that counsellor is not listed on the platform, then the admin can add the counsellor's profile details. This profile remains unverfied, until a user requests to claim it. This counsellor profile is also listed in the public counsellor list, but with an unverified label. Once a user has successfully claimed the profile, it becomes verified and is no longer available to claim. In this case the Admin needs to approve the claim request to assign the unverfied profile to the requesting counsellor. How do we add new admins? By default, the web-app has a single admin, when it is instantiated. As of now, there is no provision to add an admin role from the web-app's interface itself. We have kept it this way to avoid someone maliciously becoming an admin and tampering with the data. If someone wants to become an admin, it should be brought up to the notice of the development team. After proper background check and consent, the developers can run a script and add the admin role to the user. It is advisable to keep the passwords for admin hard to crack. The web-app anyways comes with a default 2-factor authentication, which requires 6-digit OTP sent to the registered phone number after entering the password. It is also recommended for Admin to logout explicitly everytime. Revenue Model The Revenue model can be broken down in 2 parts: For counsellors For platform Revenue model for counsellors The counsellors can earn through 2 ways: Direct booking of sessions by clients Purchase of Client Subscription plans created by the Counsellor The counsellors provides their services to clients by taking sessions. The client needs to pay an amount for taking that session. This amount is deposited in the Umang Wellness account. After the payment cycle (usually 14 days), the sum of all such payments of the counsellor is cummulated and should be sent by Admin to the counsellor's payment method. The payment method must be collected by the Admin at first and have it saved seperately from the web-app as of v2.0. The platform does not earn from direct booking of the session. Just the transaction fees for the razorpay payment gateway is cut, and the remaining should be sent to the counsellor. The admin can see the amount to pay, in the payments section. The counsellor can also create their own subscription plans for their clients to provide 24/7 chat access and bundled sessions. If a client purchases such subscription, then this amount shall also be completely transfered to the counsellor by the end of the payment cycle. Revenue model for platform There is no concept of platform-charges per session from the version V2.0. The platform earns through counsellor subscription plans purchases. This is the only way through which the platform earns. By default, a counsellor has a free subscription attached, when he signs-up. The subscripiton determines the limit-cap. It determines how much sessions a counsellor can take, how much client he can have, and which mode of services are available. In order to gain access to more resources, a counsellor needs to buy a higher-tier subscription plan. The amount that the counsellor pays for the susbcription is the amount that is earned by the platform. The amount is directly deposited in the Umang Wellness account. How to handle refund for cancelled sessions? A counsellor has the ability to cancel a session, after a client has booked one. In that case, the refund for the session must be processed immediately to the client. The admin is notified of such action in the Refund's section and through email. The admin needs to reach out to client through support mail and ask for any necessary information for refunding the payment or payment method. He should then must process the full refund excluding any transaction fee charges to the client. The exact amount to refund can be seen in the Refund's section in the Admin panel. When are counsellors able to provide their own service? A counsellor should must own a profile in order to provide service from it. A counsellor is able to provide service if his profile is completed and his phone number is verified. After that he also needs to set his available timings and pricings. Optionally he can also create subscription plans for clients to provide access to 24/7 chat and bundled sessions. How to send payment to counsellors? A counsellor can earn through 2 ways. Either through direct bookings of the sessions, or by purchase of subscription plans by clients. The counsellor gets the full amount from these purchases. The admin should first collect and store the payment method for each counsellor outside of the Umang Wellness platform. After every payment cycle (14 days), the admin can go to the Payment's section to see the exact amount to be sent to the counsellor for his direct session bookings and subscription purchases. After noting this amount, the admin must process the same to the counsellor's payment method outside of the platform. Once the admin processes the payment, he needs to come back to the Payment's section and mark that payment as processed. An automated email will be sent to the counsellor for the confirmation of processed payment. How to keep track of funds that we have received? There are 3 kinds of funds that the admin can receive: Payments from direct session booking from Clients. Client's purchase of Client subscription plans created by their Counsellor. Counsellor's purchase of Counsellor subscription plans created by the platform. The first two are the income of counsellor and the last is the income of the platform. In order to view all these payments at once, the admin can visit the Transaction section in the admin panel. Over there he can see the transactions for these 3 types of transactions. He can also see the filtered results for a specific type of transaction. Allowing counsellors to create their own subscription plans As of version v2.0, the counsellors are now allowed to create their own custom subscription plans for their clients. Through this, the counsellor can provide bundled sessions at possiblly a discounted rate. The counsellor can also give access to 24/7 chat through subscriptions. Through these subscriptions, we hope to keep the clients engaged in a better way with their counsellor. The amount paid by the clients to purchase such subscription, is directly paid back to the counsellor (after deducting the razorpay payment gateway transaction fees) at the end of the payment cycle (usually 14 days). This provides an another way of creating money for the counsellor.","title":"Business Flow Guide"},{"location":"business-flow-guide/#business-flow-guide","text":"The Umang Wellness platform is primarily focused on providing psychological services on the web by bringing the client and counsellor together. This guide gives all the information on how the Umang Wellness platform is structured and what you should know from the business perspective. It gives detailed information about all the different modules that affect the business.","title":"Business Flow Guide"},{"location":"business-flow-guide/#multi-role-users","text":"From version v2.0, Umang Wellness platform allows Multi Role users. There are 3 roles on the platform as follow: Client Counsellor Admin A user can have either one or more roles. A user can have all the roles at once, i.e - a user can be all Client , Counsellor , and Admin at once. To learn more about them, check out the Client guides , Counsellor guides and Admin guides respectively.","title":"Multi Role users"},{"location":"business-flow-guide/#client","text":"The Client is the primary user on the platform. Client is supposed to be the service consumer. Anyone can become a client by simply signing-up as Client. Once a client has signed-up he/she needs to complete his/her profile to get started. In order to complete the profile, the client also needs to verify his/her mobile number through OTP. Once the Client has completed his/her profile and verified himself/herself, he/she can then start using the service. Following are some of the things that a Client can do: View the list of Counsellors on the platform. Select the Counsellor of his/her choice. Book sessions with the selected Counsellor. Subscribe to the Counsellor to get access to 24/7 chat and bundled sessions.","title":"Client"},{"location":"business-flow-guide/#counsellor","text":"The Counsellor is the service provider on the platform. Anyone can become a counsellor, until they are aligning with some mandatory requirements to become a counsellor. In order to sign-up as a Counsellor, one needs to provide the information about his/her quaification and specialities. Once that information is filled, one needs to confirm to some mandatory requirements to provide counselling on the platform. A Counsellor needs to wait for an approval by the Admin after signing-up. The Admin may contact the newly signed-up counsellor through his/her provided email to do some checks and verifications. The Counsellor needs to complete his Profile , set Available Timings and set My Pricings in order to start providing counselling services to clients. Following is the list of some things that the Counsellor can do: Set Availale Timings for session Set custom pricings to mode of services. Create Subscription plans for Clients to allow 24/7 chat and bundled sessions. From v2.0, we are introducing Counsellor Subscriptions. Everything that a counsellor can provide has a limit-cap. These subscriptions provide a means to increase that limit-caps. By default, the counsellor gets a free subscription when he signs-up. A counsellor can always upgrade/downgrade a subscription. In case of downgrade, the refund will be processed for the remanining days in the subscription.","title":"Counsellor"},{"location":"business-flow-guide/#admin","text":"The Admin is the web-app's administrator. He/She can keep track of list of all clients and counsellors. They can activate/deactivate any user. Admins are also responsible for configuring various parameters in the system. These parameters can be minimum charge for each session, advance booking days limit, payment cycle period, etc. Admin is also responisble to approve new counsellors. They are also responsible for managing the subscription plans for the counsellors. An Admin can also add new counsellors by his/her own into the system. These newly added profiles by the admin remains unverified, until a user requests to claim it. The admin can see all the payment transaction in the system. He is responsible to send the payments to counsellors. He is also responsible to send full-refunds to clients when a counsellor cancels a session. The admin is also able to view various logs. For example he is able to see the Audit logs, which keeps track of any update operation. He can also view the Error logs, which shows any error faced by a user.","title":"Admin"},{"location":"business-flow-guide/#how-do-we-add-new-counsellors","text":"There are 2 ways in which new counsellors can be added into the system: User himself creates the profile Admin adds the profile Any user can become a counsellor by going through the sign-up process of becoming a counsellor. Once he does that, he needs to wait for an approval from the admin. Meanwhile he needs to complete his profile, verify his phone number, and set his availability timings and pricings. Once he goes through all these steps, he is listed as a verified counsellor in the public counsellor list, and is ready to provide services to clients. An admin can also add a counsellor profile. The admin may have got this information from scrape data. He may have come across this counsellor on the internet. If that counsellor is not listed on the platform, then the admin can add the counsellor's profile details. This profile remains unverfied, until a user requests to claim it. This counsellor profile is also listed in the public counsellor list, but with an unverified label. Once a user has successfully claimed the profile, it becomes verified and is no longer available to claim. In this case the Admin needs to approve the claim request to assign the unverfied profile to the requesting counsellor.","title":"How do we add new counsellors?"},{"location":"business-flow-guide/#how-do-we-add-new-admins","text":"By default, the web-app has a single admin, when it is instantiated. As of now, there is no provision to add an admin role from the web-app's interface itself. We have kept it this way to avoid someone maliciously becoming an admin and tampering with the data. If someone wants to become an admin, it should be brought up to the notice of the development team. After proper background check and consent, the developers can run a script and add the admin role to the user. It is advisable to keep the passwords for admin hard to crack. The web-app anyways comes with a default 2-factor authentication, which requires 6-digit OTP sent to the registered phone number after entering the password. It is also recommended for Admin to logout explicitly everytime.","title":"How do we add new admins?"},{"location":"business-flow-guide/#revenue-model","text":"The Revenue model can be broken down in 2 parts: For counsellors For platform","title":"Revenue Model"},{"location":"business-flow-guide/#revenue-model-for-counsellors","text":"The counsellors can earn through 2 ways: Direct booking of sessions by clients Purchase of Client Subscription plans created by the Counsellor The counsellors provides their services to clients by taking sessions. The client needs to pay an amount for taking that session. This amount is deposited in the Umang Wellness account. After the payment cycle (usually 14 days), the sum of all such payments of the counsellor is cummulated and should be sent by Admin to the counsellor's payment method. The payment method must be collected by the Admin at first and have it saved seperately from the web-app as of v2.0. The platform does not earn from direct booking of the session. Just the transaction fees for the razorpay payment gateway is cut, and the remaining should be sent to the counsellor. The admin can see the amount to pay, in the payments section. The counsellor can also create their own subscription plans for their clients to provide 24/7 chat access and bundled sessions. If a client purchases such subscription, then this amount shall also be completely transfered to the counsellor by the end of the payment cycle.","title":"Revenue model for counsellors"},{"location":"business-flow-guide/#revenue-model-for-platform","text":"There is no concept of platform-charges per session from the version V2.0. The platform earns through counsellor subscription plans purchases. This is the only way through which the platform earns. By default, a counsellor has a free subscription attached, when he signs-up. The subscripiton determines the limit-cap. It determines how much sessions a counsellor can take, how much client he can have, and which mode of services are available. In order to gain access to more resources, a counsellor needs to buy a higher-tier subscription plan. The amount that the counsellor pays for the susbcription is the amount that is earned by the platform. The amount is directly deposited in the Umang Wellness account.","title":"Revenue model for platform"},{"location":"business-flow-guide/#how-to-handle-refund-for-cancelled-sessions","text":"A counsellor has the ability to cancel a session, after a client has booked one. In that case, the refund for the session must be processed immediately to the client. The admin is notified of such action in the Refund's section and through email. The admin needs to reach out to client through support mail and ask for any necessary information for refunding the payment or payment method. He should then must process the full refund excluding any transaction fee charges to the client. The exact amount to refund can be seen in the Refund's section in the Admin panel.","title":"How to handle refund for cancelled sessions?"},{"location":"business-flow-guide/#when-are-counsellors-able-to-provide-their-own-service","text":"A counsellor should must own a profile in order to provide service from it. A counsellor is able to provide service if his profile is completed and his phone number is verified. After that he also needs to set his available timings and pricings. Optionally he can also create subscription plans for clients to provide access to 24/7 chat and bundled sessions.","title":"When are counsellors able to provide their own service?"},{"location":"business-flow-guide/#how-to-send-payment-to-counsellors","text":"A counsellor can earn through 2 ways. Either through direct bookings of the sessions, or by purchase of subscription plans by clients. The counsellor gets the full amount from these purchases. The admin should first collect and store the payment method for each counsellor outside of the Umang Wellness platform. After every payment cycle (14 days), the admin can go to the Payment's section to see the exact amount to be sent to the counsellor for his direct session bookings and subscription purchases. After noting this amount, the admin must process the same to the counsellor's payment method outside of the platform. Once the admin processes the payment, he needs to come back to the Payment's section and mark that payment as processed. An automated email will be sent to the counsellor for the confirmation of processed payment.","title":"How to send payment to counsellors?"},{"location":"business-flow-guide/#how-to-keep-track-of-funds-that-we-have-received","text":"There are 3 kinds of funds that the admin can receive: Payments from direct session booking from Clients. Client's purchase of Client subscription plans created by their Counsellor. Counsellor's purchase of Counsellor subscription plans created by the platform. The first two are the income of counsellor and the last is the income of the platform. In order to view all these payments at once, the admin can visit the Transaction section in the admin panel. Over there he can see the transactions for these 3 types of transactions. He can also see the filtered results for a specific type of transaction.","title":"How to keep track of funds that we have received?"},{"location":"business-flow-guide/#allowing-counsellors-to-create-their-own-subscription-plans","text":"As of version v2.0, the counsellors are now allowed to create their own custom subscription plans for their clients. Through this, the counsellor can provide bundled sessions at possiblly a discounted rate. The counsellor can also give access to 24/7 chat through subscriptions. Through these subscriptions, we hope to keep the clients engaged in a better way with their counsellor. The amount paid by the clients to purchase such subscription, is directly paid back to the counsellor (after deducting the razorpay payment gateway transaction fees) at the end of the payment cycle (usually 14 days). This provides an another way of creating money for the counsellor.","title":"Allowing counsellors to create their own subscription plans"},{"location":"semantic-versioning/","text":"Semantic Versioning Semantic Versioning is a widely-adopted version scheme that uses a three-part version number (MAJOR.MINOR.PATCH), an optional pre-release tag, and an optional build meta tag. The presence of a pre-release tag indicates substanial risk (can contain bugs), and so does the version with a MAJOR as 0. For example - 0.x.y . Semantic Versioning Specification (SemVer) The following points makes the complete spcification of Semantic Versioning. Software using Semantic Versioning MUST declare a public API. This API could be declared in the code itself or exist strictly in documentation. However it is done, it SHOULD be precise and comprehensive. A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers, and MUST NOT contain leading zeroes. X is the major version, Y is the minor version, and Z is the patch version. Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0. Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version. Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT be considered stable. Version 1.0.0 defines the public API. The way in which the version number is incremented after this release is dependent on this public API and how it changes. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards compatible functionality is introduced to the public API. It MUST be incremented if any public API functionality is marked as deprecated. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented. Major version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. It MAY also include minor and patch level changes. Patch and minor versions MUST be reset to 0 when major version is incremented. A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.\u2013. Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining version precedence. Thus two versions that differ only in the build metadata, have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3\u2014-117B344092BD. Precedence refers to how versions are compared to each other when ordered. Precedence MUST be calculated by separating the version into major, minor, patch and pre-release identifiers in that order (Build metadata does not figure into precedence). Precedence is determined by the first difference when comparing each of these identifiers from left to right as follows: Major, minor, and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has lower precedence than a normal version: Example: 1.0.0-alpha < 1.0.0. Precedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing each dot separated identifier from left to right until a difference is found as follows: Identifiers consisting of only digits are compared numerically. Identifiers with letters or hyphens are compared lexically in ASCII sort order. Numeric identifiers always have lower precedence than non-numeric identifiers. A larger set of pre-release fields has a higher precedence than a smaller set, if all of the preceding identifiers are equal. Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0. Designating development stages Software in the experimental stage (alpha or beta) often uses a zero in the first (\"MAJOR\") position of the sequence to designate its status. However, this scheme is only useful for the early stages, not for upcoming releases with established software where the version number has already progressed past 0. That is, while the software is in early developments and requires frequent updates, it's MAJOR is 0 which indicates under initial development. Once the softwares passes MAJOR 0, unstable versions are indicated with a pre-release tag, while the version without pre-release tag indicates a stable version. The following table shows the comparison of different development stages: Stage Semver Notes Intial Development 0.5.2 initial version indicated by a leading zero Alpha 1.2.0-a.1 alpha version indicated by a.1 . It is written by a hyphen, which indicates pre-release tag Beta 1.2.0-b.2 beta version indicated by b.2 . It is written by a hyphen, which indicates pre-release tag Release Candidate 1.2.0-rc.3 release candidate version indicated by rc.3 . It is written by a hyphen, which indicates pre-release tag Release 1.2.0 no pre-release tag indicates a production version Post-release fixes 1.2.5 the incremented patch indicates post-release fixes Thus a typical development progresses as: Initial development stage (\"MAJOR\" as zero): 0.0.0 -> 0.0.1 -> 0.1.0 -> ..... -> 0.5.5 Alpha stage: 1.0.0-a.1 -> 1.0.0-a.2 ..... Beta stage: 1.0.0-b.1 -> 1.0.0-b.2 ..... Release candidate: 1.0.0-rc.1 -> 1.0.0-rc.2 ..... Release: 1.0.0 Post-release fixes: 1.0.1 -> 1.0.2 -> 1.0.3 ..... Summary Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes MINOR version when you add functionality in a backwards compatible manner PATCH version when you make backwards compatible bug fixes Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. Example - software that relies on version 2.1.5 is compatible with version 2.2.3 , but not nessarily with the version 3.2.4 The development stages progresses as: initial development -> alpha -> beta -> release candidate -> release -> post-release-fixes References Wikipedia Semantic Versioning guide","title":"Semantic Versioning"},{"location":"semantic-versioning/#semantic-versioning","text":"Semantic Versioning is a widely-adopted version scheme that uses a three-part version number (MAJOR.MINOR.PATCH), an optional pre-release tag, and an optional build meta tag. The presence of a pre-release tag indicates substanial risk (can contain bugs), and so does the version with a MAJOR as 0. For example - 0.x.y .","title":"Semantic Versioning"},{"location":"semantic-versioning/#semantic-versioning-specification-semver","text":"The following points makes the complete spcification of Semantic Versioning. Software using Semantic Versioning MUST declare a public API. This API could be declared in the code itself or exist strictly in documentation. However it is done, it SHOULD be precise and comprehensive. A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers, and MUST NOT contain leading zeroes. X is the major version, Y is the minor version, and Z is the patch version. Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0. Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version. Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT be considered stable. Version 1.0.0 defines the public API. The way in which the version number is incremented after this release is dependent on this public API and how it changes. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards compatible functionality is introduced to the public API. It MUST be incremented if any public API functionality is marked as deprecated. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented. Major version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. It MAY also include minor and patch level changes. Patch and minor versions MUST be reset to 0 when major version is incremented. A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.\u2013. Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining version precedence. Thus two versions that differ only in the build metadata, have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3\u2014-117B344092BD. Precedence refers to how versions are compared to each other when ordered. Precedence MUST be calculated by separating the version into major, minor, patch and pre-release identifiers in that order (Build metadata does not figure into precedence). Precedence is determined by the first difference when comparing each of these identifiers from left to right as follows: Major, minor, and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has lower precedence than a normal version: Example: 1.0.0-alpha < 1.0.0. Precedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing each dot separated identifier from left to right until a difference is found as follows: Identifiers consisting of only digits are compared numerically. Identifiers with letters or hyphens are compared lexically in ASCII sort order. Numeric identifiers always have lower precedence than non-numeric identifiers. A larger set of pre-release fields has a higher precedence than a smaller set, if all of the preceding identifiers are equal. Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.","title":"Semantic Versioning Specification (SemVer)"},{"location":"semantic-versioning/#designating-development-stages","text":"Software in the experimental stage (alpha or beta) often uses a zero in the first (\"MAJOR\") position of the sequence to designate its status. However, this scheme is only useful for the early stages, not for upcoming releases with established software where the version number has already progressed past 0. That is, while the software is in early developments and requires frequent updates, it's MAJOR is 0 which indicates under initial development. Once the softwares passes MAJOR 0, unstable versions are indicated with a pre-release tag, while the version without pre-release tag indicates a stable version. The following table shows the comparison of different development stages: Stage Semver Notes Intial Development 0.5.2 initial version indicated by a leading zero Alpha 1.2.0-a.1 alpha version indicated by a.1 . It is written by a hyphen, which indicates pre-release tag Beta 1.2.0-b.2 beta version indicated by b.2 . It is written by a hyphen, which indicates pre-release tag Release Candidate 1.2.0-rc.3 release candidate version indicated by rc.3 . It is written by a hyphen, which indicates pre-release tag Release 1.2.0 no pre-release tag indicates a production version Post-release fixes 1.2.5 the incremented patch indicates post-release fixes Thus a typical development progresses as: Initial development stage (\"MAJOR\" as zero): 0.0.0 -> 0.0.1 -> 0.1.0 -> ..... -> 0.5.5 Alpha stage: 1.0.0-a.1 -> 1.0.0-a.2 ..... Beta stage: 1.0.0-b.1 -> 1.0.0-b.2 ..... Release candidate: 1.0.0-rc.1 -> 1.0.0-rc.2 ..... Release: 1.0.0 Post-release fixes: 1.0.1 -> 1.0.2 -> 1.0.3 .....","title":"Designating development stages"},{"location":"semantic-versioning/#summary","text":"","title":"Summary"},{"location":"semantic-versioning/#given-a-version-number-majorminorpatch-increment-the","text":"MAJOR version when you make incompatible API changes MINOR version when you add functionality in a backwards compatible manner PATCH version when you make backwards compatible bug fixes Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. Example - software that relies on version 2.1.5 is compatible with version 2.2.3 , but not nessarily with the version 3.2.4","title":"Given a version number MAJOR.MINOR.PATCH, increment the:"},{"location":"semantic-versioning/#the-development-stages-progresses-as","text":"initial development -> alpha -> beta -> release candidate -> release -> post-release-fixes","title":"The development stages progresses as:"},{"location":"semantic-versioning/#references","text":"Wikipedia Semantic Versioning guide","title":"References"}]}